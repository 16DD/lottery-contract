// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

contract SafeTransfer {
  address private constant ETH_ADDRESS = 0x0000000000000000000000000000000000000000;

  function safeTokenTransfer(address _token, address payable _to, uint256 _amount) internal {
    if (address(_token) == ETH_ADDRESS) {
      _safeTransferETH(_to, _amount);
    } else {
      _safeTransfer(_token, _to, _amount);
    }
  }

  function tokenTransfer(address _token, address payable _to, uint256 _amount) internal {
    if (address(_token) == ETH_ADDRESS) {
      _to.transfer(_amount);
    } else {
      _safeTransfer(_token, _to, _amount);
    }
  }

  function safeApprove(address token, address to, uint256 amount) internal {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, amount));
    require(success && (data.length == 0 || abi.decode(data, (bool))), "ST: approve failed");
  }

  function _safeTransfer(address token, address to, uint256 amount) internal {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, amount));
    require(success && (data.length == 0 || abi.decode(data, (bool))), "ST: transfer failed");
  }

  function _safeTransferFrom(address token, address from, uint256 amount) internal {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));
    require(success && (data.length == 0 || abi.decode(data, (bool))), "ST: transfer from failed");
  }

  function _safeTransferFrom(address token, address from, address to, uint256 amount) internal {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, amount));
    require(success && (data.length == 0 || abi.decode(data, (bool))), "ST: transfer from failed");
  }

  function _safeTransferETH(address to, uint256 value) internal {
    (bool success,) = to.call{value: value}("");
    require(success, "ST: eth transfer failed"); 
  }
}